<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React v15</title>
    <style>
      body {
        text-align: center;
      }
      #root {
        padding: 100px;
        margin: 20px;
        border: 1px solid;
      }
    </style>
  </head>
  <script type="text/javascript">
    var invariant = function (condition, format, a, b, c, d, e, f) {
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment " +
              "for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function () {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }

        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
      }
    };
  </script>
  <body>
    <div id="root"></div>
    <script>
      var emptyObject = {};
      // ReactNodeTypes.js
      var ReactNodeTypes = {
        NATIVE: 0,
        COMPOSITE: 1,
        EMPTY: 2,

        getType: function (node) {
          if (node === null || node === false) {
            return ReactNodeTypes.EMPTY;
          } else if (ReactElement.isValidElement(node)) {
            if (typeof node.type === "function") {
              return ReactNodeTypes.COMPOSITE;
            } else {
              return ReactNodeTypes.NATIVE;
            }
          }
          invariant(false, "Unexpected node: %s", node);
        },
      };
      // ReactNoopUpdateQueue.js
      var ReactNoopUpdateQueue = {
        // todo
      };
      // ReactCurrentOwner.js
      var ReactCurrentOwner = {
        current: null,
      };
      // ReactElement.js
      var REACT_ELEMENT_TYPE =
        (typeof Symbol === "function" &&
          Symbol.for &&
          Symbol.for("react.element")) ||
        0xeac7;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true,
      };

      var ReactElement = function (type, key, ref, self, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,

          type,
          key,
          ref,
          props,

          _owner: owner,
        };
        return element;
      };

      ReactElement.createElement = function (type, config, children) {
        var propName;

        var props = {};

        var key = null;
        var ref = null;
        var self = null;
        var source = null;

        if (config != null) {
          ref = config.ref === undefined ? null : config.ref;
          key = config.key === undefined ? null : "" + config.key;

          self = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source;

          for (propName in config) {
            if (
              config.hasOwnProperty(propName) &&
              !RESERVED_PROPS.hasOwnProperty(propName)
            ) {
              props[propName] = config[propName];
            }
          }
        }

        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0; i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }

          props.children = childArray;
        }

        // 省略 default props 逻辑
        return ReactElement(
          type,
          key,
          ref,
          self,
          source,
          ReactCurrentOwner.current,
          props
        );
      };

      ReactElement.isValidElement = function (object) {
        return (
          typeof object === "object" &&
          object !== null &&
          object.$$typeof === REACT_ELEMENT_TYPE
        );
      };
      // ReactComponent.js
      function ReactComponent(props, context, updater) {
        this.props = props;
        // this.context = context;
        // this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }

      ReactComponent.prototype.isReactComponent = {};

      var ReactClassComponent = function () {};
      Object.assign(ReactClassComponent.prototype, ReactComponent.prototype);

      // ReactClass.js
      function mixSpecIntoComponent(Constructor, spec) {
        if (!spec) {
          return;
        }

        invariant(
          typeof spec !== "function",
          "ReactClass: You're attempting to " +
            "use a component class or function as a mixin. Instead, just use a " +
            "regular object."
        );
        invariant(
          !ReactElement.isValidElement(spec),
          "ReactClass: You're attempting to " +
            "use a component as a mixin. Instead, just use a regular object."
        );

        var proto = Constructor.prototype;
        var autoBindPairs = proto.__reactAutoBindPairs;

        for (var name in spec) {
          if (!spec.hasOwnProperty(name)) {
            continue;
          }

          var property = spec[name];
          var isAlreadyDefined = proto.hasOwnProperty(name);

          
          // Setup methods on prototype:
          // The following member methods should not be automatically bound:
          // 1. Expected ReactClass methods (in the "interface").
          // 2. Overridden methods (that were mixed in).
          
          // var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          // var isFunction = typeof property === 'function'
          // var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
          
          // 省略了验证保留方法和 mixin 的逻辑
          proto[name] = property
        }
      }
      var ReactClass = {
        createClass: function (spec) {
          var Constructor = function (props, context, updater) {
            this.props = props;
            this.context = context;
            // this.refs = emptyObject;
            // this.updater = updater || ReactNoopUpdateQueue;

            this.state = null;

            // ReactClasses doesn't have constructors. Instead, they use the
            // getInitialState and componentWillMount methods for initialization.

            var initialState = this.getInitialState
              ? this.getInitialState()
              : null;

            this.state = initialState;
          };

          Constructor.prototype = new ReactClassComponent();
          Constructor.prototype.constructor = Constructor;
          Constructor.prototype.__reactAutoBindPairs = [];

          mixSpecIntoComponent(Constructor, spec);

          return Constructor;
        },
      };

      // React.js
      var React = {
        createElement: ReactElement.createElement,
        createClass: ReactClass.createClass,
      };

      // ReactDOMTextComponent.js
      var ReactDOMTextComponent = function (text) {
        // TODO: This is really a ReactText (ReactNode), not a ReactElement
        this._currentElement = text;
        this._stringText = "" + text;

        // ReactDOMComponentTree uses these:
        this._nativeNode = null;
        this._nativeParent = null;

        // Properties
        this._domID = null;
        this._mountIndex = 0;
        this._closingComment = null;
        this._commentNodes = null;
      };

      Object.assign(ReactDOMTextComponent.prototype, {
        mountComponent: function () {
          console.log("todo mountComponent..");
        },
        receiveComponent: function () {
          console.log("todo mountComponent..");
        },
      });

      // ReactDOMComponent.js
      function ReactDOMComponent(element) {
        var tag = element.type;
        // validateDangerousTag(tag);
        this._currentElement = element;
        this._tag = tag.toLowerCase();
        this._namespaceURI = null;
        this._renderedChildren = null;
        this._previousStyle = null;
        this._previousStyleCopy = null;
        this._nativeNode = null;
        this._nativeParent = null;
        this._rootNodeID = null;
        this._domID = null;
        this._nativeContainerInfo = null;
        this._wrapperState = null;
        this._topLevelWrapper = null;
        this._flags = 0;
      }

      ReactDOMComponent.displayName = "ReactDOMComponent";
      ReactDOMComponent.Mixin = {
        mountComponent: function () {
          console.log("mount component todo..");
        },
        receiveComponent: function () {
          console.log("receiveComponent todo..");
        },
      };
      Object.assign(
        ReactDOMComponent.prototype,
        ReactDOMComponent.Mixin
        //  ReactMultiChild.Mixin
      );
      // ReactInstanceMap.js
      /**
       * `ReactInstanceMap` maintains a mapping from a public facing stateful
       * instance (key) and the internal representation (value). This allows public
       * methods to accept the user facing instance as an argument and map them back
       * to internal methods.
       */

      // TODO: Replace this with ES6: var ReactInstanceMap = new Map();
      var ReactInstanceMap = {
        /**
         * This API should be called `delete` but we'd have to make sure to always
         * transform these to strings for IE support. When this transform is fully
         * supported we can rename it.
         */
        remove: function (key) {
          key._reactInternalInstance = undefined;
        },

        get: function (key) {
          return key._reactInternalInstance;
        },

        has: function (key) {
          return key._reactInternalInstance !== undefined;
        },

        set: function (key, value) {
          key._reactInternalInstance = value;
        },
      };

      // ReactUpdateQueue.js
      /**
       * ReactUpdateQueue allows for state updates to be scheduled into a later
       * reconciliation step.
       */
      var ReactUpdateQueue = {};

      // ================ Reconciler        =================
      // ReactReconciler.js
      var ReactReconciler = {
        mountComponent: function (
          internalInstance,
          transaction,
          nativeParent,
          nativeContainerInfo,
          context
        ) {
          var markup = internalInstance.mountComponent(
            transaction,
            nativeParent,
            nativeContainerInfo,
            context
          );
          return markup;
        },
      };
      // ReactUpdates.js
      var ReactUpdates = {
        batchedUpdates: function (callback, a, b, c, d, e) {
          // 省略 transaction 部分
          // ReactDefaultBatchingStrategy.batchedUpdates(callback, a, b, c, d, e);
          // 直接调
          callback.call(null, a, b, c, d, e);
        },
      };
      // ReactCompositeComponent.js
      var nextMountID = 1;
      var ReactCompositeComponentMixin = {
        construct: function (element) {
          this._currentElement = element;
          this._rootNodeID = null;
          this._instance = null;
          this._nativeParent = null;
          this._nativeContainerInfo = null;

          // See ReactUpdateQueue
          this._pendingElement = null;
          this._pendingStateQueue = null;
          this._pendingReplaceState = false;
          this._pendingForceUpdate = false;

          this._renderedNodeType = null;
          this._renderedComponent = null;
          this._context = null;
          this._mountOrder = 0;
          this._topLevelWrapper = null;

          // See ReactUpdates and ReactUpdateQueue.
          this._pendingCallbacks = null;
        },
        /**
         * Filters the context object to only contain keys specified in
         * `contextTypes`
         *
         * @param {object} context
         * @return {?object}
         * @private
         */
        _maskContext: function (context) {
          var Component = this._currentElement.type;
          var contextTypes = Component.contextTypes;
          if (!contextTypes) {
            return emptyObject;
          }
          var maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          return maskedContext;
        },
        _processProps: function (newProps) {
          return newProps;
        },
        _processContext: function (context) {
          var maskedContext = this._maskContext(context);
          return maskedContext;
        },
        /**
         *  Initializes the component, renders markup, and registers event listeners.
         * */

        mountComponent: function (
          transaction,
          nativeParent,
          nativeContainerInfo,
          context
        ) {
          this._context = context;
          this._mountOrder = nextMountID++;
          this._nativeParent = nativeParent;
          this._nativeContainerInfo = nativeContainerInfo;

          var publicProps = this._processProps(this._currentElement.props);
          var publicContext = this._processContext(context);

          var Component = this._currentElement.type;

          // Initialize the public class
          var inst;
          var renderedElement;

          if (Component.prototype && Component.prototype.isReactComponent) {
            inst = new Component(publicProps, publicContext, ReactUpdateQueue);
          } else {
            inst = Component(publicProps, publicContext, ReactUpdateQueue);
            if (inst == null || inst.render == null) {
              renderedElement = inst;
              invariant(
                inst === null ||
                  inst === false ||
                  ReactElement.isValidElement(inst),
                "%s(...): A valid React element (or null) must be returned. You may have " +
                  "returned undefined, an array or some other invalid object.",
                Component.displayName || Component.name || "Component"
              );
              inst = new StatelessComponent(Component);
            }
          }

          // These should be set up in the constructor, but as a convenience for
          // simpler class abstractions, we set them up after the fact.
          inst.props = publicProps;
          inst.context = publicContext;
          inst.refs = emptyObject;
          inst.updater = ReactUpdateQueue;

          this._instance = inst;

          // Store a reference from the instance back to the internal representation
          ReactInstanceMap.set(inst, this);

          var initialState = inst.state;
          if (initialState === undefined) {
            inst.state = initialState = null;
          }
          invariant(
            typeof initialState === "object" && !Array.isArray(initialState),
            "%s.state: must be set to an object or null",
            this.getName() || "ReactCompositeComponent"
          );

          this._pendingStateQueue = null;
          this._pendingReplaceState = false;
          this._pendingForceUpdate = false;

          var markup;
          if (inst.unstable_handleError) {
            markup = this.performInitialMountWithErrorHandling(
              renderedElement,
              nativeParent,
              nativeContainerInfo,
              transaction,
              context
            );
          } else {
            markup = this.performInitialMount(
              renderedElement,
              nativeParent,
              nativeContainerInfo,
              transaction,
              context
            );
          }

          if (inst.componentDidMount) {
            // transaction
            //   .getReactMountReady()
            //   .enqueue(inst.componentDidMount, inst);
            console.log("不考虑 transaction , 直接调用 componentDidMount..");
            inst.componentDidMount.call(inst);
          }

          return markup;
        },
        receiveComponent: function () {
          console.log("receive component todo...3");
        },
        _renderValidatedComponentWithoutOwnerOrContext: function () {
          var inst = this._instance;
          var renderedComponent = inst.render();

          return renderedComponent;
        },
        _renderValidatedComponent: function () {
          var renderedComponent;
          ReactCurrentOwner.current = this;
          try {
            renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
          } finally {
            ReactCurrentOwner.current = null;
          }
          invariant(
            // TODO: An `isValidNode` function would probably be more appropriate
            renderedComponent === null ||
              renderedComponent === false ||
              ReactElement.isValidElement(renderedComponent),
            "%s.render(): A valid React element (or null) must be returned. You may have " +
              "returned undefined, an array or some other invalid object.",
            this.getName() || "ReactCompositeComponent"
          );
          return renderedComponent;
        },
        performInitialMount: function (
          renderedElement,
          nativeParent,
          nativeContainerInfo,
          transaction,
          context
        ) {
          var inst = this._instance;
          if (inst.componentWillMount) {
            inst.componentWillMount();
            // When mounting, calls to `setState` by `componentWillMount` will set
            // `this._pendingStateQueue` without triggering a re-render.
            if (this._pendingStateQueue) {
              inst.state = this._processPendingState(inst.props, inst.context);
            }
          }

          // If not a stateless component, we now render
          if (renderedElement === undefined) {
            renderedElement = this._renderValidatedComponent();
          }

          this._renderedNodeType = ReactNodeTypes.getType(renderedElement);
          this._renderedComponent = this._instantiateReactComponent(
            renderedElement
          );

          var markup = ReactReconciler.mountComponent(
            this._renderedComponent,
            transaction,
            nativeParent,
            nativeContainerInfo
            // this._processChildContext(context)
          );

          return markup;
        },
        getName: function () {
          var type = this._currentElement.type;
          var constructor = this._instance && this._instance.constructor;
          return (
            type.displayName ||
            (constructor && constructor.displayName) ||
            type.name ||
            (constructor && constructor.name) ||
            null
          );
        },
      };
      var ReactCompositeComponent = {
        Mixin: ReactCompositeComponentMixin,
      };
      // ReactNativeComponent.js
      var genericComponentClass = ReactDOMComponent;
      var textComponentClass = ReactDOMTextComponent;
      var ReactNativeComponent = {
        createInternalComponent: function (element) {
          return new genericComponentClass(element);
        },
        createInstanceForText: function (text) {
          return new textComponentClass(text);
        },
      };
      // instantiateReactComponent.js
      // To avoid a cyclic dependency, we create the final class in this module
      var ReactCompositeComponentWrapper = function (element) {
        this.construct(element);
      };
      Object.assign(
        ReactCompositeComponentWrapper.prototype,
        ReactCompositeComponent.Mixin,
        {
          _instantiateReactComponent: instantiateReactComponent,
        }
      );
      function isInternalComponentType(type) {
        return (
          typeof type === "function" &&
          typeof type.prototype !== "undefined" &&
          typeof type.prototype.mountComponent === "function" &&
          typeof type.prototype.receiveComponent === "function"
        );
      }
      function instantiateReactComponent(node) {
        var instance;
        if (node === null || node === false) {
          console.warn("省略 null / false 的逻辑");
          // instance = ReactEmptyComponent.create(instantiateReactComponent)
        } else if (typeof node === "object") {
          var element = node;
          if (typeof element.type === "string") {
            instance = ReactNativeComponent.createInternalComponent(element);
          } else if (isInternalComponentType(element.type)) {
            instance = new element.type(element);
          } else {
            instance = new ReactCompositeComponentWrapper(element);
          }
        } else if (typeof node === "string" || typeof node === "number") {
          instance = ReactNativeComponent.createInstanceForText(node);
        } else {
          invariant(
            false,
            "Encountered invalid React node of type %s",
            typeof node
          );
        }

        instance._mountIndex = 0;
        instance._mountImage = null;
        return instance;
      }

      // ================ ReactDOM renderer =================
      // ReactDOMContainerInfo.js
      var DOC_NODE_TYPE = 9;
      function ReactDOMContainerInfo(topLevelWrapper, node) {
        var info = {
          _topLevelWrapper: topLevelWrapper,
          _idCounter: 1,
          _ownerDocument: node
            ? node.nodeType === DOC_NODE_TYPE
              ? node
              : node.ownerDocument
            : null,
          _tag: node ? node.nodeName.toLowerCase() : null,
          _namespaceURI: node ? node.namespaceURI : null,
        };

        return info;
      }
      // ReactMount.js
      var topLevelRootCounter = 1;
      var TopLevelWrapper = function () {
        this.rootID = topLevelRootCounter++;
      };
      TopLevelWrapper.prototype.isReactComponent = {};
      TopLevelWrapper.prototype.render = function () {
        return this.props;
      };

      function mountComponentIntoNode(
        wrapperInstance,
        container,
        transaction,
        shouldReuseMarkup,
        context
      ) {
        var markup = ReactReconciler.mountComponent(
          wrapperInstance,
          transaction,
          null,
          ReactDOMContainerInfo(wrapperInstance, container),
          context
        );

        wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
        ReactMount._mountImageIntoNode(
          markup,
          container,
          wrapperInstance,
          shouldReuseMarkup,
          transaction
        );
      }

      function batchedMountComponentIntoNode(
        componentInstance,
        container,
        shouldReuseMarkup,
        context
      ) {
        var transaction = null;
        // 暂时省略 transaction 部分
        // var transaction = ReactUpdates.ReactReconcilerTransaction.getPooled(
        //   true
        // );
        // transaction.perform(
        //   mountComponentIntoNode,
        //   null,
        //   componentInstance,
        //   container,
        //   transaction,
        //   shouldReuseMarkup,
        //   context
        // );
        // ReactUpdates.ReactReconcilerTransaction.release(transaction);
        // 其实就是直接调用了
        mountComponentIntoNode.call(
          null,
          componentInstance,
          container,
          transaction,
          shouldReuseMarkup,
          context
        );
      }
      var ReactMount = {
        _renderNewRootComponent: function (
          nextElement,
          container,
          shouldReuseMarkup,
          context
        ) {
          var componentInstance = instantiateReactComponent(nextElement);

          ReactUpdates.batchedUpdates(
            batchedMountComponentIntoNode,
            componentInstance,
            container,
            shouldReuseMarkup,
            context
          );

          return componentInstance;
        },
        _renderSubtreeIntoContainer: function (
          parentComponent,
          nextElement,
          container,
          callback
        ) {
          var nextWrapperElement = ReactElement(
            TopLevelWrapper,
            null,
            null,
            null,
            null,
            null,
            nextElement
          );
          // 省略更新或者卸载的逻辑
          // var prevComponent = getTopLevelWrapperInContainer(container)

          // 只考虑第一次渲染
          // var shouldReuseMarkup = false
          // var reactRootElement = getReactRootElementInContainer(container);
          var component = ReactMount._renderNewRootComponent(
            nextWrapperElement,
            container,
            false, // shouldReuseMarkup,
            emptyObject
          )._renderedComponent.getPublicInstance();

          if (callback) {
            callback.call(component);
          }
        },
        render: function (nextElement, container, callback) {
          return ReactMount._renderSubtreeIntoContainer(
            null,
            nextElement,
            container,
            callback
          );
        },
      };

      // ReactDOM.js
      var ReactDOM = {
        render: ReactMount.render,
      };
    </script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"></script> -->
    <script src="../build/offical/babel.js"></script>
    <script type="text/babel">
      var HelloMessage = React.createClass({
        componentDidMount: function () {
          console.error("componentDidMount..");
        },
        render: function () {
          return <div>Hello {this.props.name}</div>;
        },
      });

      ReactDOM.render(
        <HelloMessage name="John" />,
        document.getElementById("root")
      );
    </script>

    <a href="https://gist.github.com/maechabin/fbc528b248bbec2c72b14357e7c99310"
      >React v15 toturial</a
    >
  </body>
</html>
